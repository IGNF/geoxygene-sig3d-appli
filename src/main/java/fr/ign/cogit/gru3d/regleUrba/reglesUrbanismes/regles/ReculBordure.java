//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB)
// Reference Implementation, v2.1.3-b01-fcs
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source
// schema.
// Generated on: 2009.10.26 at 12:24:15 PM CET
//

package fr.ign.cogit.gru3d.regleUrba.reglesUrbanismes.regles;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

import javax.media.j3d.Appearance;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Shape3D;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

import com.sun.j3d.utils.geometry.GeometryInfo;

import fr.ign.cogit.geoxygene.api.spatial.coordgeom.IDirectPosition;
import fr.ign.cogit.geoxygene.api.spatial.coordgeom.IDirectPositionList;
import fr.ign.cogit.geoxygene.api.spatial.geomaggr.IMultiPoint;
import fr.ign.cogit.geoxygene.api.spatial.geomprim.IOrientableSurface;
import fr.ign.cogit.geoxygene.api.spatial.geomroot.IGeometry;
import fr.ign.cogit.geoxygene.sig3d.calculation.Proximity;
import fr.ign.cogit.geoxygene.sig3d.convert.java3d.ConversionJava3DGeOxygene;
import fr.ign.cogit.geoxygene.sig3d.geometry.Box3D;
import fr.ign.cogit.geoxygene.sig3d.sample.Symbology;
import fr.ign.cogit.geoxygene.spatial.coordgeom.DirectPosition;
import fr.ign.cogit.geoxygene.spatial.coordgeom.GM_Polygon;
import fr.ign.cogit.geoxygene.spatial.geomaggr.GM_MultiPoint;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_Point;
import fr.ign.cogit.gru3d.regleUrba.Executor;
import fr.ign.cogit.gru3d.regleUrba.representation.ContrainteDistance;
import fr.ign.cogit.gru3d.regleUrba.representation.Incoherence;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Batiment;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Parcelle;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Toit;
import fr.ign.cogit.gru3d.regleUrba.util.Prospect;

/**
 * 
 *        This software is released under the licence CeCILL
 * 
 *        see LICENSE.TXT
 * 
 *        see <http://www.cecill.info/ http://www.cecill.info/
 * 
 * 
 * 
 * @copyright IGN
 * 
 * @author Brasebin Mickaël
 * 
 * @version 1.0
 *
 * <p>
 * Java class for ReculBordure complex type.
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType name="ReculBordure">
 *   &lt;complexContent>
 *     &lt;extension base="{}Recul">
 *       &lt;sequence>
 *         &lt;element name="distanceRecul" type="{}Distance"/>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ReculBordure", propOrder = { "distanceRecul" })
public class ReculBordure extends Recul {

  @XmlElement(required = true)
  protected Distance distanceRecul;

  /**
   * Gets the value of the distanceRecul property.
   * 
   * @return possible object is {@link Distance }
   */
  @Override
  public Distance getDistanceRecul() {
    return this.distanceRecul;
  }

  /**
   * Sets the value of the distanceRecul property.
   * 
   * @param value allowed object is {@link Distance }
   */
  public void setDistanceRecul(Distance value) {
    this.distanceRecul = value;
  }

  public ReculBordure() {

  }

  public ReculBordure(Distance d) {
    this.distanceRecul = d;

  }

  @Override
  public String toString() {
    // TODO Auto-generated method stub
    return "Recul d'une distance de " + this.distanceRecul.toString()
        + " par rapport aux bordures de la parcelle";
  }

  @Override
  public List<Incoherence> isConsequenceChecked(Parcelle p, boolean represent) {

    List<Incoherence> lIncoherence = new ArrayList<Incoherence>();

    List<Batiment> lBati = p.getlBatimentsContenus();
    int nbBati = lBati.size();

    List<Parcelle> lParcelles = p.getlParcelleBordante();
    int nbParcelles = lParcelles.size();

    if (this.distanceRecul instanceof DistanceEuclidienne) {
      // Bati 3D, on regarde la distance entre la route et les toits des
      // batiments

      // On fabrique
      DistanceEuclidienne distEcul = (DistanceEuclidienne) this.distanceRecul;

      for (int i = 0; i < nbBati; i++) {
        Toit t = lBati.get(i).getToit();

        for (int j = 0; j < nbParcelles; j++) {

          IMultiPoint mp = new GM_MultiPoint(t.getGeom().coord());

          double distance = mp.distance(lParcelles.get(j).getGeom());

          if (distance < distEcul.getDMin()) {

            if (Executor.VERBOSE) {
              System.out
                  .println("Condition non vérifiée :  Distance minimale non respectée à la bordure de la parcelle");

            }
            // BranchGroup bg = null;

            // bg = this.generateBranchGroup(lParcelles.get(j), t);

            if (represent) {
              Box3D b = new Box3D(lBati.get(i).getGeom());
              Box3D b2 = new Box3D(lParcelles.get(j).getGeom());

              IDirectPosition dp1 = t.getGeom().centroid();
              IDirectPosition dp2 = lParcelles.get(j).getGeom().centroid();

              dp1.setZ(b.getLLDP().getZ());
              dp2.setZ(b2.getLLDP().getZ());

              GM_Point ptIni;
              if (Double.isNaN(dp1.getX())) {
                ptIni = new GM_Point(b.getLLDP());
              } else {
                ptIni = new GM_Point(dp1);
              }

              GM_Point ptFin;

              if (Double.isNaN(dp2.getX())) {
                ptFin = new GM_Point(b2.getLLDP());
              } else {
                ptFin = new GM_Point(dp2);
              }

              BranchGroup bg = ContrainteDistance.generateBG(
                  ptIni,
                  ptFin,
                  20,
                  Color.red,
                  10,
                  2,
                  5,
                  Symbology.class.getResource(
                      "/demo3D/reglesurba/directionParcelle.png").getPath());

              lIncoherence.add(new Incoherence(this, p, bg));
            } else {
              lIncoherence.add(null);
              return lIncoherence;

            }
          }

        }

      }

    } else if (this.distanceRecul instanceof DistanceFHauteur) {

      DistanceFHauteur dH = (DistanceFHauteur) this.distanceRecul;

      double coeff = dH.getCoefficient();
      bouclebati: for (int i = 0; i < nbBati; i++) {
        // On prend la hauteur du batiment
        Batiment bati = lBati.get(i);

        Box3D bBati = new Box3D(bati.getGeom());
        double zmin = bBati.getLLDP().getZ();

        Toit t = bati.getToit();

        IDirectPositionList dpl = t.getGeom().coord();
        int nbPoints = dpl.size();

        for (int j = 0; j < nbPoints; j++) {
          // On regarde si chaque point des triangles respectent
          // H < d / coefficient
          IDirectPosition dp = dpl.get(j);

          double hauteur = dp.getZ() - zmin;

          GM_Point point = new GM_Point(dp);

          for (int k = 0; k < nbParcelles; k++) {
            double distance = point.distance(lParcelles.get(k).getGeom());

            if (hauteur > coeff * distance + dH.getHauteurOrigine()) {

              if (Executor.VERBOSE) {
                System.out
                    .println("Condition non vérifiée :  Distance fonction de hauteur non respectée à la bordure d'une parcelle");

              }

              if (represent) {

                BranchGroup bg = null;

                bg = this.generateBranchGroup(p, lParcelles.get(k), dp, dH);

                lIncoherence.add(new Incoherence(this, p, bg));
                continue bouclebati;
              } else {
                lIncoherence.add(null);
                return lIncoherence;
              }

            }
          }

        }

      }

    }

    if (Executor.VERBOSE) {
      if (lIncoherence.size() == 0) {

        System.out
            .println("Condition vérifiée :  Distance fonction de hauteur à la bordure d'une parcelle respectée");

      }

    }
    return lIncoherence;

  }

  /*
   * private BranchGroup generateBranchGroup(Parcelle pActu, Parcelle p, double
   * zMax) { BranchGroup bg = new BranchGroup(); GM_Object obj =
   * pActu.getGeom().buffer(((DistanceEuclidienne)this.getDistanceRecul
   * ()).getDMin()).intersection(p.getGeom()); GM_Solid sol = (GM_Solid)
   * From2DGeomTo3DGeom.convertitFromGeom(obj,p.getGeom
   * ().coord().get(0).getZ(), zMax); List<GM_OrientableSurface> lsurf = new
   * ArrayList<GM_OrientableSurface>(); lsurf.addAll(sol.getListeFacettes());
   * GeometryInfo geomInfo = ConversionJava3DGeOxygene
   * .fromOrientableSToTriangleArray(lsurf); Appearance ap =
   * Util.genereApparence(true, Color.cyan,0.5, true); Shape3D shape = new
   * Shape3D(geomInfo.getGeometryArray(), ap); bg.addChild(shape); return bg; }
   */

  private BranchGroup generateBranchGroup(Parcelle p, Toit t) {

    BranchGroup bg = new BranchGroup();
    Proximity c = new Proximity();
    c.nearest(t.getGeom().coord(), p.getGeom().coord());

    DirectPosition dp1 = new DirectPosition(c.nearest2.getX(),
        c.nearest2.getY(), c.nearest.getZ() - 2);
    DirectPosition dp2 = new DirectPosition(c.nearest.getX(), c.nearest.getY(),
        c.nearest.getZ() - 2);

    Appearance ap = Prospect.genereApparence(true, Color.red, 0.4, true);

    bg.addChild(new Shape3D(Prospect.genereLigne(dp1, dp2, Color.red), ap));

    return bg;
  }

  private BranchGroup generateBranchGroup(Parcelle p, Parcelle p2,
      IDirectPosition dp, DistanceFHauteur d) {

    BranchGroup bg = new BranchGroup();

    GM_Polygon polygone = (GM_Polygon) Prospect.calculeEmprise(p.getGeom(),
        p2.getGeom(), d);

    List<IOrientableSurface> lsurf = new ArrayList<IOrientableSurface>();
    lsurf.add(polygone);

    GeometryInfo geomInfo = ConversionJava3DGeOxygene
        .fromOrientableSToTriangleArray(lsurf);

    Appearance ap = Prospect.genereApparence(true, Color.red, 1, true);

    Shape3D shape = new Shape3D(geomInfo.getGeometryArray(), ap);

    bg.addChild(shape);

    return bg;
  }

  public IGeometry genereContrainteEuclidienne(Parcelle p) {
    List<Parcelle> lParcelles = p.getlParcelleBordante();

    int nbParcelles = lParcelles.size();

    IGeometry geom = p.getGeom();
    for (int i = 0; i < nbParcelles; i++) {

      IGeometry geomTemp = lParcelles.get(i).getGeom()
          .buffer(((DistanceEuclidienne) this.getDistanceRecul()).getDMin());

      if (geom == null) {
        return null;
      }

      if (geomTemp == null) {
        return null;
      }

      geom = geom.difference(geomTemp);

    }

    return geom;
  }

}
