//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB)
// Reference Implementation, v2.1.3-b01-fcs
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source
// schema.
// Generated on: 2009.10.26 at 12:24:15 PM CET
//

package fr.ign.cogit.gru3d.regleUrba.reglesUrbanismes.regles;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

import javax.media.j3d.Appearance;
import javax.media.j3d.BranchGroup;
import javax.media.j3d.Shape3D;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

import com.sun.j3d.utils.geometry.GeometryInfo;

import fr.ign.cogit.geoxygene.api.spatial.coordgeom.IDirectPosition;
import fr.ign.cogit.geoxygene.api.spatial.coordgeom.IDirectPositionList;
import fr.ign.cogit.geoxygene.api.spatial.geomprim.IOrientableSurface;
import fr.ign.cogit.geoxygene.api.spatial.geomroot.IGeometry;
import fr.ign.cogit.geoxygene.sig3d.calculation.Proximity;
import fr.ign.cogit.geoxygene.sig3d.convert.java3d.ConversionJava3DGeOxygene;
import fr.ign.cogit.geoxygene.sig3d.geometry.Box3D;
import fr.ign.cogit.geoxygene.sig3d.sample.Symbology;
import fr.ign.cogit.geoxygene.spatial.coordgeom.GM_Polygon;
import fr.ign.cogit.geoxygene.spatial.geomaggr.GM_MultiSurface;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_OrientableSurface;
import fr.ign.cogit.geoxygene.spatial.geomprim.GM_Point;
import fr.ign.cogit.geoxygene.spatial.geomroot.GM_Object;
import fr.ign.cogit.gru3d.regleUrba.Executor;
import fr.ign.cogit.gru3d.regleUrba.representation.ContrainteDistance;
import fr.ign.cogit.gru3d.regleUrba.representation.Incoherence;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Batiment;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Parcelle;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Toit;
import fr.ign.cogit.gru3d.regleUrba.util.Prospect;

/**
 * 
 *        This software is released under the licence CeCILL
 * 
 *        see LICENSE.TXT
 * 
 *        see <http://www.cecill.info/ http://www.cecill.info/
 * 
 * 
 * 
 * @copyright IGN
 * 
 * @author Brasebin Mickaël
 * 
 * @version 1.0
 *
 * <p>
 * Java class for ReculAutreBatiment complex type.
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType name="ReculAutreBatiment">
 *   &lt;complexContent>
 *     &lt;extension base="{}Recul">
 *       &lt;sequence>
 *         &lt;element name="distanceRecul" type="{}Distance"/>
 *       &lt;/sequence>
 *     &lt;/extension>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ReculAutreBatiment", propOrder = { "distanceRecul" })
public class ReculAutreBatiment extends Recul {

  @XmlElement(required = true)
  protected Distance distanceRecul;

  /**
   * Gets the value of the distanceRecul property.
   * 
   * @return possible object is {@link Distance }
   */
  @Override
  public Distance getDistanceRecul() {
    return this.distanceRecul;
  }

  /**
   * Sets the value of the distanceRecul property.
   * 
   * @param value allowed object is {@link Distance }
   */
  public void setDistanceRecul(Distance value) {
    this.distanceRecul = value;
  }

  public ReculAutreBatiment() {

  }

  public ReculAutreBatiment(Distance d) {
    this.distanceRecul = d;
  }

  @Override
  public String toString() {

    return "Recul d'une distance de " + this.distanceRecul
        + " par rapport aux autres batiments de la parcelle";

  }

  @Override
  public List<Incoherence> isConsequenceChecked(Parcelle p, boolean represent) {

    List<Incoherence> lIncoherence = new ArrayList<Incoherence>();

    List<Batiment> lBati = p.getlBatimentsContenus();
    int nbBati = lBati.size();

    if (nbBati < 2) {

      if (Executor.VERBOSE) {
        System.out
            .println("Condition vérifiée :  Recul entre batiments (il n'y en a moins que 2)");

      }
      return lIncoherence;
    }

    if (this.distanceRecul instanceof DistanceEuclidienne) {
      // Bati 3D, on regarde la distance entre la route et les toits des
      // batiments

      // On fabrique
      DistanceEuclidienne distEcul = (DistanceEuclidienne) this.distanceRecul;

      for (int i = 0; i < nbBati; i++) {
        Toit t = lBati.get(i).getToit();

        for (int j = i + 1; j < nbBati; j++) {

          IGeometry geomT = t.getGeom();
          IGeometry geomB = lBati.get(j).getToit().getGeom();

          double distance = geomT.distance(geomB);

          if (distance < distEcul.getDMin()) {

            if (Executor.VERBOSE) {
              System.out
                  .println("Condition non vérifiée :  Distance minimale non respectée un autre bâtiment");

            }

            if (represent) {
              /*
               * BranchGroup bg = null;
               * 
               * bg = this.generateBranchGroup(lBati.get(i).getToit(),
               * lBati.get(j) .getToit());
               */

              GM_Point ptIni = new GM_Point(t.getGeom().centroid());

              if (Double.isNaN(ptIni.getPosition().getX())) {
                ptIni = new GM_Point(t.getGeom().coord().get(0));
              }

              GM_Point ptFin = new GM_Point(lBati.get(j).getToit().getGeom()
                  .centroid());

              if (Double.isNaN(ptFin.getPosition().getX())) {
                ptIni = new GM_Point(lBati.get(j).getToit().getGeom().coord()
                    .get(0));
              }

              Box3D b = new Box3D(t.getGeom().coord());
              ptIni.getPosition().setZ(b.getLLDP().getZ());
              ptFin.getPosition().setZ(b.getLLDP().getZ());

              BranchGroup bg = ContrainteDistance.generateBG(
                  ptIni,
                  ptFin,
                  20,
                  Color.red,
                  10,
                  2,
                  5,
                  Symbology.class.getResource(
                      "/demo3D/reglesurba/directionBati.png").getPath());

              lIncoherence.add(new Incoherence(this, p, bg));
            } else {

              lIncoherence.add(new Incoherence(this));
              return lIncoherence;

            }

          }

        }

      }

    } else if (this.distanceRecul instanceof DistanceFHauteur) {

      DistanceFHauteur dH = (DistanceFHauteur) this.distanceRecul;

      double coeff = dH.getCoefficient();
      bouclebati: for (int i = 0; i < nbBati; i++) {
        // On prend la hauteur du batiment
        Batiment bati = lBati.get(i);

        Box3D bBati = new Box3D(bati.getGeom());
        double zmin = bBati.getLLDP().getZ();

        Toit t = bati.getToit();

        IDirectPositionList dpl = t.getGeom().coord();
        int nbPoints = dpl.size();

        for (int j = 0; j < nbPoints; j++) {
          // On regarde si chaque point des triangles respectent
          // H < d / coefficient
          IDirectPosition dp = dpl.get(j);

          double hauteur = dp.getZ() - zmin;

          GM_Point point = new GM_Point(dp);

          for (int k = i + 1; k < nbBati; k++) {
            double distance = point.distance(lBati.get(k).getToit().getGeom());

            if (hauteur > coeff * distance + dH.getHauteurOrigine()) {

              if (Executor.VERBOSE) {
                System.out
                    .println("Condition non vérifiée :  Distance fonction de hauteur non respectée par rapport à un autre bâtiment");

              }

              BranchGroup bg = null;

              bg = this.generateBranchGroup(lBati.get(k), bati.getToit(), dp,
                  dH);

              lIncoherence.add(new Incoherence(this, p, bg));
              continue bouclebati;

            }
          }

        }

      }

    }

    if (Executor.VERBOSE) {

      if (lIncoherence.size() == 0) {
        System.out
            .println("Condition vérifiée :  Distance fonction de hauteur à la bordure d'une parcelle respectée");
      }
    }
    return lIncoherence;

  }

  private BranchGroup generateBranchGroup(Toit t, Toit t2) {
    BranchGroup bg = new BranchGroup();
    Proximity c = new Proximity();
    c.nearest(t.getGeom().coord(), t2.getGeom().coord());

    bg.addChild(new Shape3D(Prospect.genereLigne(c.nearest, c.nearest2, Color.red)));

    return bg;
  }

  private BranchGroup generateBranchGroup(Batiment b, Toit t,
      IDirectPosition dp, DistanceFHauteur d) {

    BranchGroup bg = new BranchGroup();

    GM_Polygon polygone = (GM_Polygon) Prospect.calculeEmprise(t.getGeom(),
        b.getGeom(), d);

    List<IOrientableSurface> lsurf = new ArrayList<IOrientableSurface>();
    lsurf.add(polygone);

    GeometryInfo geomInfo = ConversionJava3DGeOxygene
        .fromOrientableSToTriangleArray(lsurf);

    Appearance ap = Prospect.genereApparence(true, Color.red, 0.4, true);

    Shape3D shape = new Shape3D(geomInfo.getGeometryArray(), ap);
    BranchGroup bd = Prospect.generePoint(dp, ap);

    bg.addChild(shape);
    bg.addChild(bd);

    return bg;
  }

  public IGeometry genereContrainteEuclidienne(Parcelle p) {
    List<Batiment> lBatiments = p.getlBatimentsContenus();

    int nbBatiment = lBatiments.size();

    IGeometry geom = (GM_Object) p.getGeom().clone();
    for (int i = 0; i < nbBatiment; i++) {

      IGeometry geom2 = lBatiments.get(i).getToit().getGeom();

      if (!geom2.isValid()) {

        if (geom2 instanceof GM_MultiSurface<?>) {
          Prospect.clean((GM_MultiSurface<GM_OrientableSurface>) geom2, 1);

        }

      }

      geom2 = geom2.buffer(((DistanceEuclidienne) this.getDistanceRecul())
          .getDMin());

      if (geom2 == null || geom2.isEmpty() || !geom.isValid()) {

        return null;
      }

      geom = geom.difference(geom2);
      if (geom == null || geom.isEmpty()) {

        return null;
      }

    }

    return geom;
  }

}
