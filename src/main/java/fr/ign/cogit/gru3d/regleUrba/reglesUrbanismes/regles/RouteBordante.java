//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB)
// Reference Implementation, v2.1.3-b01-fcs
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source
// schema.
// Generated on: 2009.10.26 at 12:24:15 PM CET
//

package fr.ign.cogit.gru3d.regleUrba.reglesUrbanismes.regles;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;

import fr.ign.cogit.gru3d.regleUrba.Executor;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Parcelle;
import fr.ign.cogit.gru3d.regleUrba.schemageo.Route;

/**
 * 
 *        This software is released under the licence CeCILL
 * 
 *        see LICENSE.TXT
 * 
 *        see <http://www.cecill.info/ http://www.cecill.info/
 * 
 * 
 * 
 * @copyright IGN
 * 
 * @author Brasebin Mickaël
 * 
 * @version 1.0
 *
 * <p>
 * Java class for RouteBordante complex type.
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType name=&quot;RouteBordante&quot;&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base=&quot;{}Antecedent&quot;&gt;
 *       &lt;sequence&gt;
 *         &lt;element name=&quot;types&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; maxOccurs=&quot;unbounded&quot;/&gt;
 *         &lt;element name=&quot;noms&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}string&quot; maxOccurs=&quot;unbounded&quot;/&gt;
 *         &lt;element name=&quot;lLargeursRoutes&quot; type=&quot;{}MinMax&quot; maxOccurs=&quot;unbounded&quot;/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "RouteBordante", propOrder = { "types", "noms",
    "lLargeursRoutes" })
public class RouteBordante extends Antecedent {

  public void setlLargeursRoutes(List<MinMax> lLargeursRoutes) {
    this.lLargeursRoutes = lLargeursRoutes;
  }

  public void setTypes(List<String> types) {
    this.types = types;
  }

  public void setNoms(List<String> noms) {
    this.noms = noms;
  }

  @XmlElement(required = true)
  protected List<String> types;
  @XmlElement(required = true)
  protected List<String> noms;
  @XmlElement(required = true)
  protected List<MinMax> lLargeursRoutes;

  /**
   * Gets the value of the types property.
   * <p>
   * This accessor method returns a reference to the live list, not a snapshot.
   * Therefore any modification you make to the returned list will be present
   * inside the JAXB object. This is why there is not a <CODE>set</CODE> method
   * for the types property.
   * <p>
   * For example, to add a new item, do as follows:
   * 
   * <pre>
   * getTypes().add(newItem);
   * </pre>
   * <p>
   * Objects of the following type(s) are allowed in the list {@link String }
   */
  public List<String> getTypes() {
    if (this.types == null) {
      this.types = new ArrayList<String>();
    }
    return this.types;
  }

  /**
   * Gets the value of the noms property.
   * <p>
   * This accessor method returns a reference to the live list, not a snapshot.
   * Therefore any modification you make to the returned list will be present
   * inside the JAXB object. This is why there is not a <CODE>set</CODE> method
   * for the noms property.
   * <p>
   * For example, to add a new item, do as follows:
   * 
   * <pre>
   * getNoms().add(newItem);
   * </pre>
   * <p>
   * Objects of the following type(s) are allowed in the list {@link String }
   */
  public List<String> getNoms() {
    if (this.noms == null) {
      this.noms = new ArrayList<String>();
    }
    return this.noms;
  }

  /**
   * Gets the value of the lLargeursRoutes property.
   * <p>
   * This accessor method returns a reference to the live list, not a snapshot.
   * Therefore any modification you make to the returned list will be present
   * inside the JAXB object. This is why there is not a <CODE>set</CODE> method
   * for the lLargeursRoutes property.
   * <p>
   * For example, to add a new item, do as follows:
   * 
   * <pre>
   * getLLargeursRoutes().add(newItem);
   * </pre>
   * <p>
   * Objects of the following type(s) are allowed in the list {@link MinMax }
   */
  public List<MinMax> getLLargeursRoutes() {
    if (this.lLargeursRoutes == null) {
      this.lLargeursRoutes = new ArrayList<MinMax>();
    }
    return this.lLargeursRoutes;
  }

  @Override
  public String toString() {
    // TODO Auto-generated method stub
    int nbTypes = this.getTypes().size();
    int nbNoms = this.getNoms().size();
    int nbInter = this.getLLargeursRoutes().size();

    if (nbTypes + nbNoms + nbInter == 0) {

      return "La règle s'appliquera aux parcelles bordées par n'importe quelle route";
    }

    String s = "La règle s'appliquera aux parcelles bordées par les routes";

    if (nbNoms != 0) {
      s = s + "\nnommées :\n";

    }

    for (int i = 0; i < nbNoms; i++) {

      s = s + this.noms.get(i);

      if (i == nbNoms - 2) {
        s = s + " ou\n";

      } else if (i == nbNoms - 1) {

        s = s + "";
      } else {
        s = s + ",\n";

      }

    }

    if (nbTypes != 0) {
      s = s + "\n";
      if (nbNoms == 0) {

        s = s + "ou ";
      }

      s = s + "du type :\n";

    }

    for (int i = 0; i < nbTypes; i++) {

      s = s + this.types.get(i);

      if (i == nbTypes - 2) {
        s = s + " ou\n";

      } else if (i == nbTypes - 1) {

        s = s + "";
      } else {
        s = s + ",\n";

      }

    }

    if (nbInter != 0) {
      s = s + "\n";
      if (nbTypes + nbNoms == 0) {

        s = s + "ou ";
      }
      s = s + "de largeur comprise entre :\n";

    }

    for (int i = 0; i < nbInter; i++) {

      s = s + this.lLargeursRoutes.get(i);

      if (i == nbInter - 2) {
        s = s + " ou\n";

      } else if (i == nbInter - 1) {

        s = s + "";
      } else {
        s = s + ",\n";

      }

    }

    // TODO Auto-generated method stub
    return s;
  }

  /**
   * Les types de routes possibles. LEs valeurs ici présentes sont tirées de la
   * BD Topo Il s'agit des différentes valeurs possibles pour l'attribut nature
   * de la classe route
   */
  private static String[] lNomsTypes = { "Autoroute", "Quasi-autoroute",
      "Bretelle", "Route à 2 chaussées", "Route à 1 chaussée",
      "Route empierrée", "Chemin", "Bac auto", "Bac piéton", "Piste cyclable",
      "Sentier", "Escalier" };

  /**
   * Retourne les types de routes existants
   * 
   * @return
   */
  public static String[] getLNomsTypes() {
    return RouteBordante.lNomsTypes;

  }

  public RouteBordante() {
  }

  public RouteBordante(List<String> types, List<String> noms,
      List<MinMax> lLargeursRoutes) {
    this.types = types;
    this.noms = noms;
    this.lLargeursRoutes = lLargeursRoutes;
  }

  @Override
  public boolean isAntecedantChecked(Parcelle p) {

    boolean result = false;
    this.routesOk = new ArrayList<Route>();

    List<Route> lRoutes = p.getlRouteBordante();
    int nbRoutes = lRoutes.size();

    int nbTypes = this.getTypes().size();
    int nbNoms = this.getNoms().size();
    int nbLargeurs = this.getLLargeursRoutes().size();

    for (int i = 0; i < nbRoutes; i++) {

      Route r = lRoutes.get(i);

      for (int j = 0; j < nbTypes; j++) {

        if (r.getType().equalsIgnoreCase(this.types.get(j))) {
          if (Executor.VERBOSE) {
            System.out.println("Condition vérifiée : type route bordante");

          }
          this.routesOk.add(r);
          result = true;
        }

      }

      for (int j = 0; j < nbNoms; j++) {

        if (r.getNom().equalsIgnoreCase(this.noms.get(j))) {

          if (Executor.VERBOSE) {
            System.out.println("Condition vérifiée : nom route bordante");

          }
          this.routesOk.add(r);
          result = true;
        }

      }

      double l = r.getLargeur();

      for (int j = 0; j < nbLargeurs; j++) {
        MinMax m = this.lLargeursRoutes.get(j);

        if (m.getVMin() <= l && m.getVMax() >= l) {

          if (Executor.VERBOSE) {
            System.out.println("Condition vérifiée : largeur route bordante");

          }
          this.routesOk.add(r);
          result = true;
        }

      }

    }

    return result;

  }

  @XmlTransient
  private List<Route> routesOk = null;

  @XmlTransient
  public List<Route> getRoutesOk() {

    // Eliminer les doubles ....
    return this.routesOk;
  }

}
