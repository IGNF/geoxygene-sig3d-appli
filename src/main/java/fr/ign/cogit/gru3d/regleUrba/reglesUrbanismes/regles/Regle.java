//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB)
// Reference Implementation, v2.1.3-b01-fcs
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source
// schema.
// Generated on: 2009.10.26 at 12:24:15 PM CET
//

package fr.ign.cogit.gru3d.regleUrba.reglesUrbanismes.regles;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

/**
 * 
 *        This software is released under the licence CeCILL
 * 
 *        see LICENSE.TXT
 * 
 *        see <http://www.cecill.info/ http://www.cecill.info/
 * 
 * 
 * 
 * @copyright IGN
 * 
 * @author Brasebin Mickaël
 * 
 * @version 1.0
 *
 * <p>
 * Java class for Regle complex type.
 * 
 * <p>
 * The following schema fragment specifies the expected content contained within
 * this class.
 * 
 * <pre>
 * &lt;complexType name=&quot;Regle&quot;&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base=&quot;{http://www.w3.org/2001/XMLSchema}anyType&quot;&gt;
 *       &lt;sequence&gt;
 *         &lt;element name=&quot;listeAntecedents&quot; type=&quot;{}Antecedent&quot; maxOccurs=&quot;unbounded&quot;/&gt;
 *         &lt;element name=&quot;listeConsequences&quot; type=&quot;{}Consequence&quot; maxOccurs=&quot;unbounded&quot;/&gt;
 *         &lt;element name=&quot;ID&quot; type=&quot;{http://www.w3.org/2001/XMLSchema}int&quot;/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Regle", propOrder = { "id", "antecedent", "consequence" })
public class Regle {

  public Regle(int id) {
    this.id = id;
  }

  @XmlElement(required = true)
  protected List<Antecedent> antecedent;
  @XmlElement(required = true)
  protected List<Consequence> consequence;
  @XmlElement(name = "ID")
  protected int id;

  /**
   * Gets the value of the listeAntecedents property.
   * 
   * <p>
   * This accessor method returns a reference to the live list, not a snapshot.
   * Therefore any modification you make to the returned list will be present
   * inside the JAXB object. This is why there is not a <CODE>set</CODE> method
   * for the listeAntecedents property.
   * 
   * <p>
   * For example, to add a new item, do as follows:
   * 
   * <pre>
   * getListeAntecedents().add(newItem);
   * </pre>
   * 
   * 
   * <p>
   * Objects of the following type(s) are allowed in the list {@link Antecedent }
   * 
   * 
   */
  public List<Antecedent> getAntecedent() {
    if (this.antecedent == null) {
      this.antecedent = new ArrayList<Antecedent>();
    }
    return this.antecedent;
  }

  /**
   * Gets the value of the listeConsequences property.
   * 
   * <p>
   * This accessor method returns a reference to the live list, not a snapshot.
   * Therefore any modification you make to the returned list will be present
   * inside the JAXB object. This is why there is not a <CODE>set</CODE> method
   * for the listeConsequences property.
   * 
   * <p>
   * For example, to add a new item, do as follows:
   * 
   * <pre>
   * getListeConsequences().add(newItem);
   * </pre>
   * 
   * 
   * <p>
   * Objects of the following type(s) are allowed in the list
   * {@link Consequence }
   * 
   * 
   */
  public List<Consequence> getConsequence() {
    if (this.consequence == null) {
      this.consequence = new ArrayList<Consequence>();
    }
    return this.consequence;
  }

  /**
   * Gets the value of the id property.
   * 
   */
  public int getID() {
    return this.id;
  }

  /**
   * Sets the value of the id property.
   * 
   */
  public void setID(int value) {
    this.id = value;
  }

  @Override
  public String toString() {

    int nbAntecedents = this.getAntecedent().size();
    int nbConsequences = this.getConsequence().size();

    if (nbAntecedents + nbConsequences == 0) {

      return "La règle est vide";
    }

    String s = "";

    if (nbAntecedents == 0) {
      s = s + "La règle est valable pour toutes les parcelles\n";

    }

    s = s + "CONDITIONS :\n";

    for (int i = 0; i < nbAntecedents; i++) {

      s = s + this.antecedent.get(i);

      if (i == nbAntecedents - 2) {
        s = s + " ou\n ";

      } else if (i == nbAntecedents - 1) {

        s = s + "\n";
      } else {
        s = s + ",\n";

      }

    }

    if (nbConsequences == 0) {
      s = s + " Il n'y a pas de contraintes pour ces parcelles ";
      return s;

    }

    s = s + "CONSEQUENCES :\n";

    for (int i = 0; i < nbConsequences; i++) {

      s = s + this.consequence.get(i);

      if (i == nbConsequences - 2) {
        s = s + " ou\n";

      } else if (i == nbConsequences - 1) {

        s = s + ".";
      } else {
        s = s + ",\n";

      }

    }

    return s;

  }

  public Object[] toArray() {

    int nbAntecedents = this.getAntecedent().size();
    int nbConsequences = this.getConsequence().size();

    int index = 0;

    Object[] lObjet = new Object[nbAntecedents + nbConsequences];

    for (int i = 0; i < nbAntecedents; i++) {

      lObjet[index] = this.getAntecedent().get(i);
      index++;
    }

    for (int i = 0; i < nbConsequences; i++) {

      lObjet[index] = this.getConsequence().get(i);
      index++;
    }

    return lObjet;

  }

  public Regle() {
    this.getAntecedent();
    this.getConsequence();
  }
}
